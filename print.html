<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>libremidi documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">libremidi documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="funky-midi-with-libremidi"><a class="header" href="#funky-midi-with-libremidi">Funky MIDI with <a href="https://github.com/celtera/libremidi">libremidi</a></a></h1>
<p>libremidi is an all-in-one cross-platform C++20 MIDI library for both file and real-time output.
Real-time I/O supports MIDI 2 on macOS (11+) and Linux (Kernel 6.5+), and soon on Windows (the OS does not support it yet).</p>
<p>It is a fork / rewrite originally based on two libraries, but has since then almost been entirely rewritten:</p>
<ul>
<li><a href="https://github.com/theSTK/RtMidi">RtMidi</a></li>
<li><a href="https://github.com/ddiakopoulos/ModernMIDI">ModernMIDI</a></li>
</ul>
<p>Compared to its origins, it features a lot of changes and improvements:</p>
<ul>
<li><code>libremidi::observer</code> provides hotplug support.</li>
<li>Ports are identified not with a number but with a handle which enables more stability when unplugging / replugging.</li>
<li>Memory allocations and virtual function calls are greatly reduced when compared to the RtMidi base-line.
<ul>
<li>Ability to enforce fixed message sizes with boost::static_vector for hard real-time operation</li>
<li>Ability to use boost::small_vector to cover most cases.</li>
</ul>
</li>
<li>Integer timestamps everywhere, by default in nanoseconds.</li>
<li>Ability to choose different timestamping methods (e.g. relative, absolute monotonic clock, sample-based or custom timestamping...).</li>
<li>Integration of modern C++20 types (for instance std::span instead of std::vector, std::function for callbacks, etc.)</li>
<li>Standard C++ threading primitives (std::thread, std::jthread) are now used, as well as modern Linux facilities for polling control (eventfd, timerfd).</li>
<li>Most of the code has been refactored in multiple files for clarity.</li>
</ul>
<p>It also features some new &amp; improved backends:</p>
<ul>
<li>ALSA RawMidi API.</li>
<li>PipeWire.</li>
<li>Windows UWP.</li>
<li>WebMIDI in Emscripten.</li>
<li>JACK support on all platforms where it is available.</li>
<li>Computer keyboard input.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-the-library"><a class="header" href="#compiling-the-library">Compiling the library</a></h1>
<p>libremidi uses CMake as build system.
The easiest way to compile the library is to take inspiration from the CI scripts as they will install the required dependencies.</p>
<p>Some backends require an up-to-date C++20 compiler: JACK and PipeWire, as we leverage
the C++20 semaphore support.</p>
<p>Compiling the library and examples is as simple as:</p>
<pre><code class="language-bash">$ cmake -Wno-dev \
  -S path/to/libremidi \
  -B build_folder \
  -DLIBREMIDI_EXAMPLES=1 

$ cmake --build build_folder
</code></pre>
<p>libremidi is also available on <code>vcpkg</code> and <code>Nixpkgs</code>.</p>
<h2 id="on-linux--bsd"><a class="header" href="#on-linux--bsd">On Linux &amp; BSD</a></h2>
<p>Note that the ALSA and PipeWire back-end rely on timerfd and eventfd which
may not be available on very, very, very old Linux kernels (&lt; 3.x) or some BSD kernels.</p>
<p>Note that the ALSA Raw back-end also needs udev access to scan the USB peripherals.</p>
<ul>
<li>Debian &amp; Ubuntu packages for all the back-ends:</li>
</ul>
<pre><code>libasound-dev
libjack-jackd2-dev
libudev-dev
libpipewire-0.3-dev
</code></pre>
<ul>
<li>ArchLinux packages for all the back-ends:</li>
</ul>
<pre><code>alsa-lib
jack2
libpipewire
systemd-libs
</code></pre>
<h2 id="on-windows"><a class="header" href="#on-windows">On Windows</a></h2>
<p>Note that when targetting Windows Store, WinMM APIs are not available, only UWP ones.</p>
<p>Both MSVC and MSYS2 are supported (on all MSYS2 toolchains).</p>
<h2 id="on-macos--ios"><a class="header" href="#on-macos--ios">On macOS &amp; iOS</a></h2>
<p>Note that for MIDI 2 support, the application needs to target at least macOS 11.0.
e.g. <code>-DCMAKE_OSX_DEPLOYMENT_TARGET=11</code> or more recent needs to be passed to CMake.</p>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced features</a></h2>
<ul>
<li>For MIDI 1: ability to set a fixed message size upper-bound for zero-allocation scenarios, with <code>-DLIBREMIDI_SLIM_MESSAGE=&lt;NBytes&gt;</code> (in CMake or directly to the compiler)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-libremidi-in-header-only-mode"><a class="header" href="#using-libremidi-in-header-only-mode">Using libremidi in header-only mode</a></h1>
<p>The library can be used header-only, with minimal modifications to your build system if you aren't using CMake:</p>
<ul>
<li>
<p>Define <code>LIBREMIDI_HEADER_ONLY=1</code></p>
</li>
<li>
<p>Define macros for the APIs you wish to build. The possible macros are as follows:</p>
<ul>
<li>macOS: <code>LIBREMIDI_COREMIDI=1</code> and link against <code>-framework CoreMIDI -framework CoreAudio -framework CoreFoundation</code>.</li>
<li>Linux: <code>LIBREMIDI_ALSA=1</code> and link against <code>-lasound -phtread</code>.</li>
<li>Windows (WinMM): <code>LIBREMIDI_WINMM=1</code> and link against <code>winmm</code>.</li>
<li>Windows (UWP): <code>LIBREMIDI_WINUWP=1</code> ; note that there is complex linking logic detailed in the CMakeLists.txt when using UWP.</li>
<li>emscripten: <code>LIBREMIDI_EMSCRIPTEN=1</code>.</li>
<li>Any platform with JACK: <code>LIBREMIDI_JACK=1</code>.</li>
</ul>
</li>
<li>
<p>Add the <code>include</code> folder to your include path.</p>
</li>
<li>
<p><code>#include &lt;libremidi/libremidi.hpp&gt;</code> in your source code.</p>
</li>
</ul>
<p>For instance, to build the <code>midiprobe</code> example on Linux with only ALSA support, one would run:</p>
<pre><code>$ g++ ~/libremidi/tests/midiprobe.cpp \
      -std=c++20 \
      -DLIBREMIDI_ALSA=1 \
      -DLIBREMIDI_HEADER_ONLY=1 \
      -I ~/libremidi/include \
      -lasound -pthread
</code></pre>
<p>To build it on macOS, one would run:</p>
<pre><code>$ clang++ ~/libremidi/tests/midiprobe.cpp \
      -std=c++20 \
      -DLIBREMIDI_COREMIDI=1 \
      -DLIBREMIDI_HEADER_ONLY=1 \
      -I ~/libremidi/include \
      -framework CoreMIDI -framework CoreAudio -framework CoreFoundation
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-libremidi-to-your-project"><a class="header" href="#adding-libremidi-to-your-project">Adding libremidi to your project</a></h1>
<h2 id="through-cmake"><a class="header" href="#through-cmake">Through CMake</a></h2>
<p>Consider the following existing CMake project for you application:</p>
<pre><code class="language-cmake">project(my_app)

add_executable(my_app src/main.cpp)
</code></pre>
<p>Then you can add libremidi either directly for instance through a git submodule:</p>
<pre><code class="language-cmake">project(my_app)

# example of folder structure
add_subdirectory(3rdparty/libremidi)

add_executable(my_app src/main.cpp)

target_link_libraries(my_app PRIVATE libremidi)
</code></pre>
<p>Or through FetchContent:</p>
<pre><code class="language-cmake">project(my_app)

FetchContent_Declare(
    libremidi
    GIT_REPOSITORY https://github.com/celtera/libremidi
    GIT_TAG        main
)

FetchContent_MakeAvailable(libremidi)

add_executable(my_app src/main.cpp)

target_link_libraries(my_app PRIVATE libremidi)
</code></pre>
<h2 id="through-a-custom-build-system"><a class="header" href="#through-a-custom-build-system">Through a custom build-system</a></h2>
<p>If using a custom build-system, the main thing to be aware of that
CMake does automatically for you is passing the relevant flags which will enable each backend
and linking with the correct libraries.</p>
<p>For instance on Linux with ALSA:</p>
<pre><code class="language-sh">$ g++ \
  main.cpp \
  -std=c++20 \
  -I3rdparty/libremidi/include \
  -DLIBREMIDI_ALSA=1 \
  -DLIBREMIDI_HAS_UDEV=1
  -ldl
</code></pre>
<p>or on macOS with CoreMIDI:</p>
<pre><code class="language-sh">$ clang++ \
  main.cpp \
  -std=c++20 \
  -I3rdparty/libremidi/include \
  -DLIBREMIDI_COREMIDI=1 \
  -framework CoreFoundation \
  -framework CoreAudio \
  -framework CoreMIDI
</code></pre>
<p>or on Win32 with WinMM:</p>
<pre><code class="language-batch">&gt; cl.exe ^
  main.cpp ^
  /std:c++latest ^
  /I c:\libs\3rdparty\libremidi\include ^
  /DLIBREMIDI_WINMM=1 ^
  /DUNICODE=1 ^
  /D_UNICODE=1 ^
  path/to/winmm.lib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerating-ports"><a class="header" href="#enumerating-ports">Enumerating ports</a></h1>
<p>The required header is <code>#include &lt;libremidi/libremidi.hpp&gt;</code>.</p>
<p>Inputs:</p>
<pre><code class="language-cpp">libremidi::observer obs;
for(const libremidi::input_port&amp; port : obs.get_input_ports()) {
  std::cout &lt;&lt; port.port_name &lt;&lt; "\n";
}
</code></pre>
<p>Outputs:</p>
<pre><code class="language-cpp">libremidi::observer obs;
for(const libremidi::output_port&amp; port : obs.get_output_ports()) {
  std::cout &lt;&lt; port.port_name &lt;&lt; "\n";
}
</code></pre>
<p>See <code>midiprobe.cpp</code> for a simple example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-midi-1-messages-from-a-device-through-callbacks"><a class="header" href="#reading-midi-1-messages-from-a-device-through-callbacks">Reading MIDI 1 messages from a device through callbacks</a></h1>
<pre><code class="language-cpp">// Set the configuration of our MIDI port
// Note that the callback will be invoked from a separate thread,
// it is up to you to protect your data structures afterwards.
// For instance if you are using a GUI toolkit, don't do GUI actions
// in that callback !
auto my_callback = [](const libremidi::message&amp; message) {
  // how many bytes
  message.size();
  // access to the individual bytes
  message[i];
  // access to the timestamp
  message.timestamp;
};

// Create the midi object
libremidi::midi_in midi{ 
  libremidi::input_configuration{ .on_message = my_callback } 
};

// Open a given midi port. 
// The argument is a libremidi::input_port gotten from a libremidi::observer. 
midi.open_port(/* a port */);
// Alternatively, to get the default port for the system: 
midi.open_port(libremidi::midi1::in_default_port());

// Note that only one port can be open at a given time on a midi_in or midi_out object.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-midi-1-messages-to-a-device"><a class="header" href="#sending-midi-1-messages-to-a-device">Sending MIDI 1 messages to a device</a></h1>
<pre><code class="language-cpp">// Create the midi object
libremidi::midi_out midi;

// Open a given midi port. Same as for input:
midi.open_port(libremidi::midi2::out_default_port());

// Option A: send fixed amount of bytes for most basic cases
midi.send_message(144, 110, 40); // Overloads exist for 1, 2, 3 bytes

// Option B: send a raw byte array
unsigned char bytes[3] = { 144, 110, 40 };
midi.send_message(bytes, sizeof(bytes));

// Option C: std::span&lt;unsigned char&gt;
// This allows to pass std::vector, std::array and the likes
midi.send_message(std::span&lt;unsigned char&gt;{ ... your span-compatible data-structure ... });

// Option D: helpers with the libremidi::channel_events and libremidi::meta_events structs
// See libremidi/message.hpp for the full list
midi.send_message(libremidi::channel_events::note_on(channel, note, velocity));
midi.send_message(libremidi::channel_events::control_change(channel, control, value));
midi.send_message(libremidi::channel_events::pitch_bend(channel, value));
midi.send_message(libremidi::message{ /* a message */ });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-midi-2-messages-from-a-device-through-callbacks"><a class="header" href="#reading-midi-2-messages-from-a-device-through-callbacks">Reading MIDI 2 messages from a device through callbacks</a></h1>
<p>Note that MIDI 2 support is still experimental and subject to change.
Note also that the MIDI 1 and MIDI 2 send functions (not yet receive) are useable no matter
the kind of backend used (e.g. one can send UMPs to MIDI 1 backends and MIDI 1 messages to MIDI 2 backends). This conversion is done in a best-effort way.</p>
<pre><code class="language-cpp">// Set the configuration of our MIDI port, same warnings apply than for MIDI 1.
// Note that an UMP message is always at most 4 * 32 bits = 16 bytes.
// Added to the 64-bit timestamp this is 24 bytes for a libremidi::ump 
// which is definitely small enough to be passed by value.
// Note that libremidi::ump is entirely constexpr.
auto my_callback = [](libremidi::ump message) {
  // how many bytes
  message.size();
  // access to the individual bytes
  message[i];
  // access to the timestamp
  message.timestamp;
};

// Create the midi object
libremidi::midi_in midi{ 
  libremidi::ump_input_configuration{ .on_message = my_callback }
};


// Open a given midi port. 
// The argument is a libremidi::input_port gotten from a libremidi::observer. 
midi.open_port(/* a port */);
// Alternatively, to get the default port for the system: 
midi.open_port(libremidi::midi2::in_default_port());

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-midi-2-messages-to-a-device"><a class="header" href="#sending-midi-2-messages-to-a-device">Sending MIDI 2 messages to a device</a></h1>
<pre><code class="language-cpp">// Create the midi object
libremidi::midi_out midi;

// Open a given midi port. Same as for input:
midi.open_port(libremidi::midi2::out_default_port());

// Option A: send fixed amount of bytes for most basic cases
midi.send_ump(A, B, C, D); // Overloads exist for 1, 2, 3, 4 uint32_t

// Option B: send a raw byte array.
// This can contain a sequence of UMP messages.
uint32_t bytes[2] = { ... };
midi.send_ump(bytes, sizeof(bytes));

// Option C: std::span&lt;uint32_t&gt;
// This allows to pass std::vector, std::array and the likes
// This can contain a sequence of UMP messages.
midi.send_ump(std::span&lt;uint32_t&gt;{ ... your span-compatible data-structure ... });

// Option D: helpers with the libremidi::ump class
// The helpers haven't been implemented yet :(
midi.send_ump(libremidi::ump{ /* a message */ });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-file-io-usage"><a class="header" href="#midi-file-io-usage">MIDI file I/O usage</a></h1>
<h2 id="reading-a-mid-file"><a class="header" href="#reading-a-mid-file">Reading a .mid file</a></h2>
<p>See <code>midifile_dump.cpp</code> for a more complete example.</p>
<pre><code class="language-cpp">// Read raw from a MIDI file
std::ifstream file{"path/to/a.mid", std::ios::binary};

std::vector&lt;uint8_t&gt; bytes;
bytes.assign(std::istreambuf_iterator&lt;char&gt;(file), std::istreambuf_iterator&lt;char&gt;());

// Initialize our reader object
libremidi::reader r;

// Parse
libremidi::reader::parse_result result = r.parse(bytes);

// If parsing succeeded, use the parsed data
if(result != libremidi::reader::invalid) {
  for(auto&amp; track : r.tracks) {
    for(auto&amp; event : t.events) {
      std::cout &lt;&lt; (int) event.m.bytes[0] &lt;&lt; '\n';
    }
  }
}
</code></pre>
<h2 id="writing-a-mid-file"><a class="header" href="#writing-a-mid-file">Writing a .mid file</a></h2>
<pre><code class="language-cpp">// Initialize a writer object
libremidi::writer writer;

// Create tracks and events declaratively by changing the track vector directly:
writer.tracks.push_back(
  libremidi::midi_track{
    libremidi::track_event{0, 0, libremidi::channel_events::note_on(1, 45, 35)},
    libremidi::track_event{140, 0, libremidi::channel_events::note_off(1, 45, 0)},
  }
);

// Or through a builder API:
{
  int tick = 500;
  int track = 3;
  libremidi::message msg = libremidi::channel_events::note_on(1, 45, 35);

  // Tracks will be added as needed within safe limits
  writer.add_event(tick, track, msg);
}

// Read raw from a MIDI file
std::ofstream output{"output.mid", std::ios::binary};
writer.write(output);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-2-integrations"><a class="header" href="#midi-2-integrations">MIDI 2 integrations</a></h1>
<p>libremidi integrates with the existing MIDI 2 ecosystem.</p>
<h2 id="cmidi2"><a class="header" href="#cmidi2">cmidi2</a></h2>
<p>We ship Atsushi Eno's <a href="https://github.com/atsushieno/cmidi2">cmidi2</a> header-only MIDI 2 implementation as part of the library.
This allows to quickly match incoming messages with MIDI 2 types. A lot of useful utility functions are provided.</p>
<p>See the <code>midi2_echo.cpp</code> example: it uses the following printing function:</p>
<pre><code class="language-cpp">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const libremidi::ump&amp; message)
{
  // Automatic conversion from libremidi::ump&amp; to cmidi2_ump*
  const cmidi2_ump* b = message;
  
  // Read MIDI 2 information
  int bytes = cmidi2_ump_get_num_bytes(message.data[0]);
  int group = cmidi2_ump_get_group(b);
  int status = cmidi2_ump_get_status_code(b);
  int channel = cmidi2_ump_get_channel(b);
  s &lt;&lt; "[ " &lt;&lt; bytes &lt;&lt; " | " &lt;&lt; group;

  switch ((libremidi::message_type)status)
  {
    case libremidi::message_type::NOTE_ON:
      s &lt;&lt; " | note on: " &lt;&lt; channel &lt;&lt; (int)cmidi2_ump_get_midi2_note_note(b) &lt;&lt; " | "
        &lt;&lt; cmidi2_ump_get_midi2_note_velocity(b);
      break;
    case libremidi::message_type::NOTE_OFF:
      s &lt;&lt; " | note off: " &lt;&lt; channel &lt;&lt; (int)cmidi2_ump_get_midi2_note_note(b) &lt;&lt; " | "
        &lt;&lt; cmidi2_ump_get_midi2_note_velocity(b);
      break;
    case libremidi::message_type::CONTROL_CHANGE:
      s &lt;&lt; " | cc: " &lt;&lt; channel &lt;&lt; (int)cmidi2_ump_get_midi2_cc_index(b) &lt;&lt; " | "
        &lt;&lt; cmidi2_ump_get_midi2_cc_data(b);
      break;

    default:
      break;
  }
  s &lt;&lt; " ]";
  return s;
}
</code></pre>
<h2 id="ni-midi2"><a class="header" href="#ni-midi2">ni-midi2</a></h2>
<p>It is possible to enable compatibility with [ni-midi2](https://github.com/midi2-dev/ni-midi2, the MIDI Association-backed MIDI 2 implementation.
This is done with the <code>LIBREMIDI_NI_MIDI2</code> CMake switch: <code>-DLIBREMIDI_NI_MIDI2=ON</code>.</p>
<p>An example of initialisation of a MIDI 2-compliant communication can be found in the <code>midi2_interop.cpp</code> example.</p>
<p>Note that due to the complexity of MIDI 2, we believe end-users will want to build their
own, custom-tailored stack and API on top of these base layers.</p>
<p>Current interoperability features are:</p>
<ul>
<li><code>libremidi::ump</code> can be converted to <code>midi::universal_packet</code> and conversely.</li>
<li><code>libremidi::midi_out::send_ump</code> can be called with <code>midi::universal_packet</code>, <code>midi::sysex7_packet</code> and <code>midi::sysex8_packet</code>.</li>
</ul>
<p>This ensures that most MIDI-CI messages can be sent directly.
Example:</p>
<pre><code>libremidi::midi_out midiout;

...

midiout.send_ump(midi::ci::make_discovery_inquiry(my_muid, id, 0x02, 512));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-connection--disconnection-notification"><a class="header" href="#device-connection--disconnection-notification">Device connection / disconnection notification</a></h1>
<pre><code class="language-cpp">// The callbacks will be called when the relevant event happens.
// Note that they may be called from other threads than the main thread.

libremidi::observer_configuration conf{
    .input_added = [&amp;] (const libremidi::input_port&amp; id) {
      std::cout &lt;&lt; "Input connected: " &lt;&lt; id.port_name &lt;&lt; std::endl;
    },
    .input_removed = [&amp;] (const libremidi::input_port&amp; id) {
      std::cout &lt;&lt; "Input removed: " &lt;&lt; id.port_name &lt;&lt; std::endl;
    },
    .output_added = [&amp;] (const libremidi::output_port&amp; id) {
      std::cout &lt;&lt; "Output connected: " &lt;&lt; id.port_name &lt;&lt; std::endl;
    },
    .output_removed = [&amp;] (const libremidi::output_port&amp; id) {
      std::cout &lt;&lt; "Output removed: " &lt;&lt; id.port_name &lt;&lt; std::endl;
}};

libremidi::observer obs{std::move(conf)};
</code></pre>
<p>See <code>midiobserve.cpp</code> or <code>emscripten_midiin.cpp</code> for an example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>The default error handling is done with exceptions.
If exceptions are undesirable, it is also possible to set a callback function which will be invoked upon error, for the <code>midi_in</code> and <code>midi_out</code> classes.</p>
<p>(Some classes may still throw, such as when creating invalid MIDI messages with the <code>libremidi::message</code> helpers, or the <code>observer</code> classes).</p>
<pre><code class="language-cpp">// Create the configuration
libremidi::input_configuration conf{
    .on_message = /* usual message callback */
  , .on_error = [] (libremidi::midi_error code, std::string_view info) {
      // ... log error however you want
    }
  , .on_warning = [] (libremidi::midi_error code, std::string_view info) {
      // ... log warning however you want
    }
};

// Create the midi object
libremidi::midi_in midi{conf};
</code></pre>
<p>Ditto for <code>midi_out</code> and <code>midi_observer</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced configuration</a></h1>
<p>The <code>midi_in</code>, <code>midi_out</code> and <code>midi_observer</code> objects are configured through a <code>input_configuration</code> (resp. <code>output_</code>, etc.) object passed in argument to the constructor.</p>
<p>Example:</p>
<pre><code class="language-cpp">#include &lt;libremidi/configurations.hpp&gt;

...

libremidi::midi_in in{
    libremidi::input_configuration{
      .on_message = ...
    , .ignore_sysex = false
    , .ignore_sensing = true
    }
};
</code></pre>
<h2 id="custom-back-end-configuration"><a class="header" href="#custom-back-end-configuration">Custom back-end configuration</a></h2>
<p>Additionnally, each back-end supports back-end specific configuration options, to enable users to tap into advanced features of a given API while retaining the general C++ abstraction.</p>
<p>For instance, this enables to set output buffer sizes, chunking parameters, etc. for back-ends which support the feature.</p>
<pre><code class="language-cpp">#include &lt;libremidi/backends.hpp&gt;

...

libremidi::midi_in in{
    libremidi::input_configuration{
      .on_message = ...
    },
    libremidi::pipewire_input_configuration{
      .client_name = "My app"
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-sharing"><a class="header" href="#context-sharing">Context sharing</a></h1>
<p>This allows to share a single context across multiple MIDI objects (such as a <code>jack_client_t</code> with JACK, a PipeWire main loop &amp; filter, or a <code>MIDIClientRef</code> on macOS with CoreMIDI).
If no context is passed, each object will create one as they used to.</p>
<p>Example:</p>
<pre><code class="language-cpp">#include &lt;libremidi/configurations.hpp&gt;

...

libremidi::midi_in in{
    libremidi::input_configuration{.on_message = ...}
  , libremidi::alsa_seq::input_configuration{
      .client_name = "my client"
  } 
};
</code></pre>
<p>If one simply wants to share a context across libremidi objects (for instance, a single context shared across an <code>observer</code>, <code>midi_ins</code> and <code>midi_outs</code>), the following methods will create appropriate configurations from an observer's configuration:</p>
<pre><code class="language-cpp">// Create an observer with a fixed back-end
libremidi::observer obs{
    libremidi::observer_configuration{}
  , libremidi::observer_configuration_for(libremidi::API::JACK_MIDI)};

// The in and out will share the JACK client of the observer.
// Note that the observer has to outlive them.
libremidi::midi_in in{
    libremidi::input_configuration{.on_message = ...}
  , libremidi::midi_in_configuration_for(obs) 
};

libremidi::midi_out out{
    libremidi::output_configuration{...}
  , libremidi::midi_out_configuration_for(obs) 
};
</code></pre>
<p>In that case, note that the <code>obs</code> has ownership of for instance the JACK context object: it must outlive <code>in</code> and <code>out</code>.</p>
<p>The relevant examples are:</p>
<ul>
<li><code>coremidi_share.cpp</code> for a complete example for CoreMIDI.</li>
<li><code>jack_share.cpp</code> for a complete example for JACK.</li>
<li><code>pipewire_share.cpp</code> for a complete example for PipeWire.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-polling"><a class="header" href="#custom-polling">Custom polling</a></h1>
<p>Traditionnally, RtMidi (and most other MIDI libraries) opened a dedicated MIDI thread from which messages are read, and then transferred to the rest of the app.</p>
<p>If your app is based on an event loop that can poll file descriptors, such as <code>poll()</code>, the relevant back-ends will allow to instead control polling manually by providing you with the file descriptors,
which can then be injected into your app's main loop.</p>
<p>Thus, this enables complete control over threading (and can also remove the need for synchronisation as this allows to make a callback-based yet single-threaded app, for simple applications which do not wish to reimplement MIDI filtering &amp; parsing for back-ends such as ALSA Sequencer or RawMidi).</p>
<p>Since this feature is pretty complicated to implement, we recommend checking the examples:</p>
<p>See:</p>
<ul>
<li><code>poll_share.cpp</code> for a complete example for ALSA RawMidi (recommended).</li>
<li><code>alsa_share.cpp</code> for a complete example for ALSA Seq.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timestamping"><a class="header" href="#timestamping">Timestamping</a></h1>
<p>libremidi provides many useful timestamping options for its input callbacks:</p>
<pre><code>libremidi::input_configuration conf;

// No timestamping at all, all timestamps are zero
conf.timestamps = libremidi::NoTimestamp;

// In nanoseconds, timestamp is the time since the previous event (or zero)
conf.timestamps = libremidi::Relative;

// In nanoseconds, as per an arbitrary reference which may be provided by the host API,
// e.g. since the JACK cycle start, ALSA sequencer queue creation, through AudioHostTime on macOS.
// It offers the most precise ordering between events as it's the closest to the real timestamp of
// the event as provided by the host API.
// If the API does not provide any timing, it will be mapped to SystemMonotonic instead.
conf.timestamps = libremidi::Absolute;

// In nanoseconds, as per std::steady_clock::now() or equivalent (raw if possible).
// May be less precise than Absolute as timestamping is done within the library,
// but is more useful for system-wide synchronization.
// Note: depending on the backend, Absolute and SystemMonotonic may be the same.
conf.timestamps = libremidi::SystemMonotonic;

// For APIs which are based on audio process cycles such as JACK, timestamps will be in frames since
// the beginning of the current cycle's audio buffer
conf.timestamps = libremidi::AudioFrame;

// Will call the custom timestamping function provided by the user in the input configuration.
// We try to make sure that the input timestamp is as precise as possible ; it is given in the Absolute mode.
conf.get_timestamp = [] (libremidi::timestamp absolute) -&gt; libremidi::timestamp { 
  // Map absolute timestamp to the desired time domain
  return absolute / 1e6;
};
conf.timestamps = libremidi::Custom;
</code></pre>
<p>For the absolute timestamps, the origin of the timestamp can be obtained with <code>midi_in::absolute_timestamp()</code>.
For instance, it will return the time at which the timestamping queue was created in the ALSA back-end.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queue-input"><a class="header" href="#queue-input">Queue input</a></h1>
<p>The old queued input mechanism present in RtMidi and previous versions of the library has been moved out of the code as it can be built entirely on the callback mechanism and integrated with the user application's event processing queue instead.</p>
<p>A basic example is provided in <code>qmidiin.cpp</code>.</p>
<p>We recommend if possible to instead use an asynchronous runtime in order to keep an imperative behaviour while benefiting from the non-blocking properties of async programming.</p>
<p>An example based on C++20 coroutines with Boost.Cobalt is provided in <code>coroutines.cpp</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-keyboard-input"><a class="header" href="#computer-keyboard-input">Computer keyboard input</a></h1>
<p>This backend allwos to use the computer keys to play MIDI.
The backend does not directly read the key events as this would require making the library much more complex.
Instead, it provides a callback that you can plug into your favourite GUI toolkit to process scan codes.</p>
<p>The mapping is customizable. By default:</p>
<pre><code> ,---,---,---,---,---,---,---,---,---,---,---,---,---,-------,
 | V0| V1| V2| V3| V4| V5| V6| V7| V8| V9|V10|V11|V12| &lt;-    |
 |---'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-----|
 | -&gt;| |   | C#| D#|   | F#| G#| A#|   | C#| D#|   | F#|     |
 |-----',--',--',--',--',--',--',--',--',--',--',--',--'|    |
 | Caps | C | D | E | F | G | A | B | C | D | E | F | G |    |
 |----,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'-,-'---'----|
 | -^ |   | O-| O+| V-| V+|   |   |   |   |   |   |   ----^  |
 |----'-,-',--'--,'---'---'---'---'---'---'-,-'---',--,------|
 | ctrl |  | alt |                          |altgr |  | ctrl |
 '------'  '-----'--------------------------'------'  '------'
</code></pre>
<p>Where V0 to V12 set the velocity between 0 and 127 in steps of ~10, O- / O+ increase or decrease the octave and V- / V+ increase or decrease the velocity by 10.</p>
<p>Example:</p>
<pre><code>#include &lt;libremidi/backends/keyboard/config.hpp&gt;

libremidi::kbd_input_configuration api_conf;
api_conf.set_input_scancode_callbacks(
[] )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-matrix"><a class="header" href="#feature-matrix">Feature matrix</a></h1>
<p>This table shows which feature is supported by which backend so far, for advanced features.</p>
<p>It may be because the backend does not provide the ability at all (N/A),
or because it has not been implemented yet.</p>
<h2 id="linux--bsd"><a class="header" href="#linux--bsd">Linux &amp; BSD</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>ALSA Raw</th><th>ALSA Seq</th><th>PipeWire</th></tr></thead><tbody>
<tr><td>MIDI 1</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>MIDI 2</td><td>Yes</td><td>Yes</td><td>N/A</td></tr>
<tr><td>Virtual ports</td><td>N/A</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Observer</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Scheduling</td><td>No</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="special-features"><a class="header" href="#special-features">Special features</a></h3>
<ul>
<li>
<p>The ALSA Raw back-end allows to perform chunked sending of MIDI messages,
which can be useful to upload firmwares.</p>
</li>
<li>
<p><code>libasound</code> and <code>libpipewire</code> are always loaded through <code>dlopen</code>.
JACK can also be, optionally.</p>
</li>
</ul>
<p>This allows libremidi to be built on a system with e.g. PipeWire support
without preventing application loading if the end user does not use it.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>WinMM</th><th>UWP</th><th>WinMIDI</th></tr></thead><tbody>
<tr><td>MIDI 1</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>MIDI 2</td><td>N/A</td><td>N/A</td><td>Yes</td></tr>
<tr><td>Virtual ports</td><td>N/A</td><td>No</td><td>No</td></tr>
<tr><td>Observer</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Scheduling</td><td>No</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="mac--ios"><a class="header" href="#mac--ios">Mac &amp; iOS</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>CoreMIDI</th></tr></thead><tbody>
<tr><td>MIDI 1</td><td>Yes</td></tr>
<tr><td>MIDI 2</td><td>Yes</td></tr>
<tr><td>Virtual ports</td><td>Yes</td></tr>
<tr><td>Observer</td><td>Yes</td></tr>
<tr><td>Scheduling</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="web"><a class="header" href="#web">Web</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Emscripten WebMIDI</th></tr></thead><tbody>
<tr><td>MIDI 1</td><td>Yes</td></tr>
<tr><td>MIDI 2</td><td>N/A</td></tr>
<tr><td>Virtual ports</td><td>N/A</td></tr>
<tr><td>Observer</td><td>Yes</td></tr>
<tr><td>Scheduling</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="shared-backends"><a class="header" href="#shared-backends">Shared backends</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>JACK</th></tr></thead><tbody>
<tr><td>MIDI 1</td><td>Yes</td></tr>
<tr><td>MIDI 2</td><td>N/A</td></tr>
<tr><td>Virtual ports</td><td>Yes</td></tr>
<tr><td>Observer</td><td>Yes</td></tr>
<tr><td>Scheduling</td><td>No</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
